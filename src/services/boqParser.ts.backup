// src/services/boqParser.ts
/**
 * BOQ Parser Service - Phase 2
 * Master parser to convert uploaded Excel/CSV BOQ files into standardized BOQ schema
 * 
 * Supports 19 parsing scenarios including:
 * - Multi-line descriptions, section headers, sub-items
 * - Alternative items, lump-sum detection, split rates
 * - Subtotals, grand totals, remarks, item codes
 * 
 * PHASE-3: Connect to cloud parsing lambda for very large BOQs
 */

import * as XLSX from 'xlsx';

// ==================== TYPES ====================

export interface StandardBOQRow {
  srNo: string;
  category: string;
  subCategory: string;
  description: string;
  unit: string;
  quantity: number;
  tenderRate: number;
  tenderAmount: number;
  itemCode: string | null;
  currency: string | null;
  lumpSum: boolean;
  altGroup: string | null;
  remark: boolean;
  subtotal: boolean;
  grandTotal: boolean;
  sheetName: string | null;
  rawRowIndex: number;
  original: any;
}

export interface ParseReport {
  rowsParsed: number;
  rowsSkipped: number;
  warnings: Array<{ rowIndex: number; reason: string }>;
  ambiguousHeaderConfidence: number;
  suggestedMapping: Record<string, number>;
  sheets: string[];
}

export interface ParseOptions {
  headerMapping?: Record<string, string>;
  startRow?: number;
  endRow?: number;
  sheetName?: string;
}

export interface ParseResult {
  parsedBoq: StandardBOQRow[];
  parseReport: ParseReport;
}

interface HeaderMapping {
  mapping: Record<string, string>;
  confidenceScore: number;
}

// ==================== CONSTANTS ====================

// Header mapping dictionary: maps many variants to canonical column names
const HEADER_VARIANTS: Record<string, string[]> = {
  SrNo: ['srno', 'sr no', 'sno', 's.no', 'sr.no', 'serial no', 'serialno', 'item no', 'itemno', 'sl no', 'slno', 'serial', 'no', 'seq', 'sequence', '#', 'line item', 'lineitem'],
  Description: ['description', 'item description', 'work', 'item', 'particulars', 'work description', 'desc', 'details', 'item description', 'name', 'title', 'desc description', 'item desc'],
  Unit: ['unit', 'uom', 'u.o.m', 'u o m', 'units', 'measure', 'unit of measure', 'u', 'measurement', 'meas', 'unit measure'],
  Quantity: ['qty', 'quantity', 'qnty', 'qty.', 'quntity', 'quant', 'amount qty', 'q', 'qty ordered', 'qunty', 'quantity ordered', 'qty ordered'],
  Rate: ['rate', 'unit rate', 'rate per', 'unit rate', 'price', 'rate pers', 'unit price', 'rate per unit', 'r', 'per unit', 'unit price rate'],
  Amount: ['amount', 'total', 'value', 'total amount', 'total amount', 'sum', 'total value', 'amt', 'extended amount', 'extended price', 'totalamount'],
  ItemCode: ['code', 'item code', 'dsr', 'cpwd', 'item code', 'itemcode', 'reference', 'ref code', 'item ref', 'codeno', 'item code reference'],
  Remark: ['remarks', 'remark', 'note', 'notes', 'comments', 'comment', 'remark note', 'remarks notes', 'remarks note']
};

const CURRENCY_SYMBOLS = ['₹', 'Rs.', 'Rs', 'INR', '$', 'USD', '€', 'EUR', '£', 'GBP'];

const ITEM_CODE_PATTERNS = [
  /DSR[-\s]?\d+/i,
  /CPWD[-\s]?\d+/i,
  /IS[-\s]?\d+/i,
  /PWD[-\s]?\d+/i,
  /MoRTH[-\s]?\d+/i,
  /SOR[-\s]?\d+/i
];

// ==================== MAIN PARSING FUNCTION ====================

/**
 * Parse BOQ file and convert to standardized schema
 * @param fileBuffer - Buffer or ArrayBuffer of the Excel/CSV file
 * @param fileName - Original filename
 * @param options - Parsing options (header mapping, row range, etc.)
 * @returns ParseResult with standardized BOQ rows and parse report
 */
export async function parseBoqFile(
  fileBuffer: ArrayBuffer | Buffer,
  fileName: string,
  options: ParseOptions = {}
): Promise<ParseResult> {
  console.log(`[BOQParser] ============ STARTING PARSE ============`);
  console.log(`[BOQParser] File: ${fileName}`);
  
  const parsedBoq: StandardBOQRow[] = [];
  const parseReport: ParseReport = {
    rowsParsed: 0,
    rowsSkipped: 0,
    warnings: [],
    ambiguousHeaderConfidence: 1.0,
    suggestedMapping: {},
    sheets: []
  };

  try {
    // Step 1: Read workbook
    const bytes = fileBuffer instanceof ArrayBuffer 
      ? new Uint8Array(fileBuffer)
      : fileBuffer;
    
    const workbook = XLSX.read(bytes, { type: 'array', cellStyles: true });
    console.log(`[BOQParser] Workbook loaded: ${workbook.SheetNames.length} sheets`);
    console.log(`[BOQParser] Sheet names: ${workbook.SheetNames.join(', ')}`);
    
    parseReport.sheets = workbook.SheetNames;

    // Process each sheet
    for (const sheetName of workbook.SheetNames) {
      console.log(`\n[BOQParser] ========== PARSING SHEET: ${sheetName} ==========`);
      
      const sheet = workbook.Sheets[sheetName];
      const rawRows: any[] = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
      
      console.log(`[BOQParser] Total rows in sheet: ${rawRows.length}`);
      
      // Log first 5 rows
      for (let i = 0; i < Math.min(5, rawRows.length); i++) {
        console.log(`[BOQParser] Row ${i}: ${JSON.stringify(rawRows[i].slice(0, 8))}`);
      }
      
      if (rawRows.length < 2) {
        console.warn(`[BOQParser] Sheet has less than 2 rows, skipping`);
        continue;
      }

      // Normalize rows
      const normalizedRows = unmergeAndNormalizeRows(rawRows, sheet);
      
      // Find header row
      const headerInfo = detectAndMapHeaders(normalizedRows, options.headerMapping);
      console.log(`[BOQParser] Header found at row ${headerInfo.headerRowIndex}`);
      console.log(`[BOQParser] Header mapping: ${JSON.stringify(headerInfo.mapping)}`);
      console.log(`[BOQParser] Confidence score: ${headerInfo.confidenceScore.toFixed(2)}`);
      
      updateConfidence(parseReport, headerInfo.confidenceScore);
      
      // Extract data rows
      const dataStartRow = headerInfo.headerRowIndex + 1;
      const dataRows = normalizedRows.slice(dataStartRow);
      
      console.log(`[BOQParser] Data rows to parse: ${dataRows.length}`);
      console.log(`[BOQParser] First data row: ${JSON.stringify(dataRows[0]?.slice(0, 8))}`);
      
      // If no mapping found, apply positional fallback
      if (Object.keys(headerInfo.mapping).length === 0) {
        console.warn(`[BOQParser] No columns mapped, using positional fallback`);
        headerInfo.mapping['SrNo'] = 0;
        headerInfo.mapping['Description'] = 1;
        headerInfo.mapping['Unit'] = 2;
        headerInfo.mapping['Quantity'] = 3;
        headerInfo.mapping['Rate'] = 4;
        headerInfo.mapping['Amount'] = 5;
      }
      
      // Parse data rows
      const sheetResult = parseDataRows(
        dataRows,
        headerInfo.mapping,
        sheetName,
        dataStartRow,
        parseReport
      );
      
      console.log(`[BOQParser] Sheet result: ${sheetResult.length} rows parsed`);
      parsedBoq.push(...sheetResult);
    }

    parseReport.rowsParsed = parsedBoq.length;
    
    console.log(`\n[BOQParser] ============ PARSE COMPLETE ============`);
    console.log(`[BOQParser] Total rows parsed: ${parseReport.rowsParsed}`);
    console.log(`[BOQParser] Total rows skipped: ${parseReport.rowsSkipped}`);
    console.log(`[BOQParser] Warnings: ${parseReport.warnings.length}`);
    
    return { parsedBoq, parseReport };
    
  } catch (error: any) {
    console.error('[BOQParser] PARSE FAILED:', error);
    parseReport.warnings.push({ rowIndex: -1, reason: `Parse failed: ${error.message}` });
    return { parsedBoq, parseReport };
  }
}

function updateConfidence(report: ParseReport, score: number) {
  report.ambiguousHeaderConfidence = Math.min(report.ambiguousHeaderConfidence, score);
  if (score < 0.6) {
    report.suggestedMapping = report.suggestedMapping || {};
  }
}

// ==================== HEADER DETECTION ====================

interface HeaderInfo {
  mapping: Record<string, number>;
  headerRowIndex: number;
  confidenceScore: number;
}

function detectAndMapHeaders(
  rows: any[][],
  userMapping?: Record<string, string>
): HeaderInfo {
  let bestHeaderIndex = -1;
  let bestMapping: Record<string, number> = {};
  let bestScore = 0;

  // Search first 10 rows for header
  for (let i = 0; i < Math.min(10, rows.length); i++) {
    const { mapping, score } = mapHeaderRow(rows[i]);
    
    if (score > bestScore) {
      bestScore = score;
      bestMapping = mapping;
      bestHeaderIndex = i;
    }
    
    console.log(`[BOQParser.detectHeaders] Row ${i}: score=${score.toFixed(2)}, fields=${Object.keys(mapping).length}`);
    
    // Stop if found strong match (5+ fields with good score)
    if (Object.keys(mapping).length >= 5 && score >= 0.5) {
      console.log(`[BOQParser.detectHeaders] Strong header found at row ${i}, stopping search`);
      break;
    }
  }

  if (bestHeaderIndex === -1) {
    console.warn(`[BOQParser.detectHeaders] No header row found, assuming row 0`);
    bestHeaderIndex = 0;
  }
  
  return {
    mapping: bestMapping,
    headerRowIndex: bestHeaderIndex,
    confidenceScore: bestScore
  };
}

function mapHeaderRow(row: any[]): { mapping: Record<string, number>; score: number } {
  const mapping: Record<string, number> = {};
  const priorityMatches: Record<string, { colIndex: number; score: number }> = {};

  // Try to match each column
  for (let colIndex = 0; colIndex < Math.min(row.length, 20); colIndex++) {
    const cellValue = normalizeHeaderText(String(row[colIndex] || ''));
    
    if (!cellValue) continue;
    
    // Find best match for this column
    let bestField: string | null = null;
    let bestScore = 0;
    
    for (const [fieldName, variants] of Object.entries(HEADER_VARIANTS)) {
      // Skip if already mapped
      if (fieldName in mapping) continue;
      
      for (const variant of variants) {
        const variantNorm = normalizeHeaderText(variant);
        
        if (cellValue === variantNorm) {
          // Exact match
          if (1.0 > bestScore) {
            bestField = fieldName;
            bestScore = 1.0;
          }
        } else if (cellValue.includes(variantNorm) || variantNorm.includes(cellValue)) {
          // Substring match
          if (0.7 > bestScore) {
            bestField = fieldName;
            bestScore = 0.7;
          }
        }
      }
    }
    
    if (bestField && bestScore > 0) {
      if (!(bestField in priorityMatches) || priorityMatches[bestField].score < bestScore) {
        priorityMatches[bestField] = { colIndex, score: bestScore };
      }
    }
  }

  // Apply best matches
  for (const [fieldName, match] of Object.entries(priorityMatches)) {
    mapping[fieldName] = match.colIndex;
  }

  const score = Math.min(1, Object.keys(mapping).length / 6); // 6 main fields
  console.log(`[BOQParser.mapHeaderRow] Mapped ${Object.keys(mapping).length} fields, score: ${score.toFixed(2)}`);
  console.log(`[BOQParser.mapHeaderRow] Mapping:`, mapping);
  
  return { mapping, score };
}

function normalizeHeaderText(text: string): string {
  return text
    .toLowerCase()
    .trim()
    .replace(/[^\w\s]/g, '') // Remove punctuation
    .replace(/\s+/g, ' '); // Collapse whitespace
}

// ==================== ROW NORMALIZATION ====================

function unmergeAndNormalizeRows(rows: any[][], sheet: XLSX.WorkSheet): any[][] {
  // For simplicity, just return rows as-is
  // In production: detect merged cells from sheet['!merges'] and propagate values
  return rows.map(row =>
    row.map(cell => {
      if (cell === null || cell === undefined) return '';
      return String(cell).trim();
    })
  );
}

// ==================== DATA ROW PARSING ====================

function parseDataRows(
  rows: any[][],
  headerMapping: Record<string, number>,
  sheetName: string,
  startRowIndex: number,
  parseReport: ParseReport
): StandardBOQRow[] {
  const result: StandardBOQRow[] = [];
  let currentCategory = '';
  let currentSubCategory = '';
  let lastMainItem: Partial<StandardBOQRow> | null = null;

  console.log(`[BOQParser.parseDataRows] Starting with ${rows.length} rows`);
  console.log(`[BOQParser.parseDataRows] Header mapping keys:`, Object.keys(headerMapping));
  
  // Log first few rows to see structure
  for (let j = 0; j < Math.min(3, rows.length); j++) {
    console.log(`[BOQParser.parseDataRows] Row ${j}:`, rows[j].slice(0, 10));
  }

  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    const rawRowIndex = startRowIndex + i;
    
    // Extract values using header mapping
    const srNo = getCellValue(row, headerMapping.SrNo);
    const description = getCellValue(row, headerMapping.Description);
    const unit = getCellValue(row, headerMapping.Unit);
    const qtyStr = getCellValue(row, headerMapping.Quantity);
    const rateStr = getCellValue(row, headerMapping.Rate);
    const amountStr = getCellValue(row, headerMapping.Amount);
    const itemCode = getCellValue(row, headerMapping.ItemCode);
    const remark = getCellValue(row, headerMapping.Remark);

    // DEBUG: Log extracted values for first 5 rows
    if (i < 5) {
      console.log(`[BOQParser.parseDataRows] Row ${i} extracted:`, {
        srNo,
        description,
        unit,
        qtyStr,
        rateStr,
        amountStr,
        'Col indices': {
          SrNo: headerMapping.SrNo,
          Description: headerMapping.Description,
          Unit: headerMapping.Unit,
          Quantity: headerMapping.Quantity,
          Rate: headerMapping.Rate,
          Amount: headerMapping.Amount
        },
        'Raw row (first 8 cols)': row.slice(0, 8)
      });
    }

    // Check if empty row
    if (isEmptyRow(row)) {
      parseReport.rowsSkipped++;
      continue;
    }

    // Check if page header/footer
    if (isPageHeaderFooter(description)) {
      parseReport.rowsSkipped++;
      continue;
    }

    // Parse numeric values
    const quantity = parseNumeric(qtyStr);
    const rate = parseNumeric(rateStr);
    const amount = parseNumeric(amountStr);
    const currency = detectCurrency(rateStr + amountStr);

    // Decision tree for row type
    
    // A. Section/Category heading
    if (isCategoryHeading(srNo, description, quantity, rate, amount)) {
      currentCategory = description;
      result.push(createStandardRow({
        srNo: '',
        category: description,
        subCategory: '',
        description,
        unit: '',
        quantity: 0,
        tenderRate: 0,
        tenderAmount: 0,
        itemCode: null,
        currency: null,
        lumpSum: false,
        altGroup: null,
        remark: false,
        subtotal: false,
        grandTotal: false,
        sheetName,
        rawRowIndex,
        original: row
      }));
      lastMainItem = null;
      continue;
    }

    // B. Subtotal or Grand Total
    if (isSubtotalOrGrandTotal(description, amount)) {
      const isGrand = /grand\s*total/i.test(description);
      result.push(createStandardRow({
        srNo: '',
        category: currentCategory,
        subCategory: currentSubCategory,
        description,
        unit: '',
        quantity: 0,
        tenderRate: 0,
        tenderAmount: amount,
        itemCode: null,
        currency,
        lumpSum: false,
        altGroup: null,
        remark: false,
        subtotal: !isGrand,
        grandTotal: isGrand,
        sheetName,
        rawRowIndex,
        original: row
      }));
      lastMainItem = null;
      continue;
    }

    // C. Remark row
    if (isRemarkRow(description, remark)) {
      result.push(createStandardRow({
        srNo: '',
        category: currentCategory,
        subCategory: currentSubCategory,
        description: description || remark,
        unit: '',
        quantity: 0,
        tenderRate: 0,
        tenderAmount: 0,
        itemCode: null,
        currency: null,
        lumpSum: false,
        altGroup: null,
        remark: true,
        subtotal: false,
        grandTotal: false,
        sheetName,
        rawRowIndex,
        original: row
      }));
      lastMainItem = null;
      continue;
    }

    // D. Regular data row (must have description at minimum)
    if (!description) {
      parseReport.rowsSkipped++;
      console.log(`[BOQParser] Skipping row ${i}: no description`);
      continue;
    }

    // D. Lump-sum item
    if (isLumpSum(description, unit, quantity, amount)) {
      const extractedCode = extractItemCode(description + ' ' + itemCode);
      result.push(createStandardRow({
        srNo: srNo || '',
        category: currentCategory,
        subCategory: currentSubCategory,
        description,
        unit: unit || 'LS',
        quantity: 1,
        tenderRate: amount,
        tenderAmount: amount,
        itemCode: extractedCode,
        currency,
        lumpSum: true,
        altGroup: null,
        remark: false,
        subtotal: false,
        grandTotal: false,
        sheetName,
        rawRowIndex,
        original: row
      }));
      lastMainItem = null;
      continue;
    }

    // E. Alternative item (10A, 10B, 10-1, etc.)
    const altInfo = detectAlternativeGroup(srNo);
    
    // F. Main item with potential sub-items
    if (srNo && description && (quantity > 0 || rate > 0 || amount > 0)) {
      // Calculate missing values
      let finalQty = quantity;
      let finalRate = rate;
      let finalAmount = amount;
      
      if (finalAmount === 0 && finalQty > 0 && finalRate > 0) {
        finalAmount = finalQty * finalRate;
      } else if (finalRate === 0 && finalQty > 0 && finalAmount > 0) {
        finalRate = finalAmount / finalQty;
      } else if (finalQty === 0 && finalRate > 0 && finalAmount > 0) {
        finalQty = finalAmount / finalRate;
      }

      const extractedCode = extractItemCode(description + ' ' + itemCode);
      
      const standardRow = createStandardRow({
        srNo,
        category: currentCategory,
        subCategory: currentSubCategory,
        description,
        unit,
        quantity: finalQty,
        tenderRate: finalRate,
        tenderAmount: finalAmount,
        itemCode: extractedCode,
        currency,
        lumpSum: false,
        altGroup: altInfo.baseGroup,
        remark: false,
        subtotal: false,
        grandTotal: false,
        sheetName,
        rawRowIndex,
        original: row
      });
      
      result.push(standardRow);
      lastMainItem = standardRow;
      continue;
    }

    // G. Main item header (has srNo and description but no values) - expect sub-items
    if (srNo && description && !quantity && !rate && !amount) {
      lastMainItem = {
        srNo,
        category: currentCategory,
        subCategory: currentSubCategory,
        description,
        unit: '',
        quantity: 0,
        tenderRate: 0,
        tenderAmount: 0,
        itemCode: extractItemCode(description + ' ' + itemCode),
        currency,
        lumpSum: false,
        altGroup: altInfo.baseGroup,
        remark: false,
        subtotal: false,
        grandTotal: false,
        sheetName,
        rawRowIndex,
        original: row
      };
      
      result.push(createStandardRow(lastMainItem));
      continue;
    }

    // H. Sub-item (no srNo, inherits from last main item)
    if (!srNo && lastMainItem && description && (quantity > 0 || rate > 0 || amount > 0)) {
      let finalQty = quantity;
      let finalRate = rate;
      let finalAmount = amount;
      
      if (finalAmount === 0 && finalQty > 0 && finalRate > 0) {
        finalAmount = finalQty * finalRate;
      } else if (finalRate === 0 && finalQty > 0 && finalAmount > 0) {
        finalRate = finalAmount / finalQty;
      }

      result.push(createStandardRow({
        srNo: lastMainItem.srNo || '',
        category: currentCategory,
        subCategory: currentSubCategory,
        description: `${lastMainItem.description} - ${description}`,
        unit,
        quantity: finalQty,
        tenderRate: finalRate,
        tenderAmount: finalAmount,
        itemCode: extractItemCode(description + ' ' + itemCode),
        currency,
        lumpSum: false,
        altGroup: lastMainItem.altGroup || null,
        remark: false,
        subtotal: false,
        grandTotal: false,
        sheetName,
        rawRowIndex,
        original: row
      }));
      continue;
    }

    // I. Multi-line description continuation (no srNo, no values, has text)
    if (!srNo && description && !quantity && !rate && !amount) {
      if (result.length > 0 && !result[result.length - 1].subtotal && !result[result.length - 1].grandTotal) {
        // Append to previous row's description
        result[result.length - 1].description += ' ' + description;
      }
      parseReport.rowsSkipped++;
      continue;
    }

    // J. Unknown/unparseable row
    parseReport.rowsSkipped++;
    parseReport.warnings.push({
      rowIndex: rawRowIndex,
      reason: `Could not classify row: srNo=${srNo}, desc=${description?.substring(0, 30)}`
    });
  }

  return result;
}

// ==================== HELPER FUNCTIONS ====================

function getCellValue(row: any[], colIndex: number | undefined): string {
  if (colIndex === undefined || colIndex < 0 || colIndex >= row.length) {
    return '';
  }
  const val = row[colIndex];
  if (val === null || val === undefined) return '';
  return String(val).trim();
}

function isEmptyRow(row: any[]): boolean {
  return row.every(cell => !cell || String(cell).trim() === '');
}

function isPageHeaderFooter(text: string): boolean {
  const lower = text.toLowerCase();
  return /page\s+\d+/i.test(lower) || /continued/i.test(lower);
}

function isCategoryHeading(srNo: string, desc: string, qty: number, rate: number, amount: number): boolean {
  if (!desc) return false;
  if (srNo || qty > 0 || rate > 0 || amount > 0) return false;
  // Check if all caps or contains "section" keyword
  return desc === desc.toUpperCase() || /^(section|chapter|part|trade)/i.test(desc);
}

function isSubtotalOrGrandTotal(desc: string, amount: number): boolean {
  if (!desc) return false;
  return /total/i.test(desc) && amount > 0;
}

function isRemarkRow(desc: string, remark: string): boolean {
  if (!desc && !remark) return false;
  const text = (desc + ' ' + remark).toLowerCase();
  return /^note:/i.test(text) || /^remark:/i.test(text);
}

function isLumpSum(desc: string, unit: string, qty: number, amount: number): boolean {
  if (!desc || amount === 0) return false;
  const lower = unit.toLowerCase();
  return (!unit || lower === 'ls' || lower === 'lump' || lower === 'lumpsum') && qty === 0;
}

function detectAlternativeGroup(srNo: string): { baseGroup: string | null; isAlternative: boolean } {
  if (!srNo) return { baseGroup: null, isAlternative: false };
  
  // Match patterns like: 10A, 10(a), 10-1, 10.1
  const match = srNo.match(/^(\d+)[a-zA-Z\-\.\(]/);
  if (match) {
    return { baseGroup: match[1], isAlternative: true };
  }
  
  return { baseGroup: null, isAlternative: false };
}

function extractItemCode(text: string): string | null {
  for (const pattern of ITEM_CODE_PATTERNS) {
    const match = text.match(pattern);
    if (match) return match[0];
  }
  return null;
}

function parseNumeric(value: string): number {
  if (!value) return 0;
  
  // Remove currency symbols, commas, spaces
  let cleaned = value;
  for (const symbol of CURRENCY_SYMBOLS) {
    cleaned = cleaned.replace(new RegExp(symbol.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), '');
  }
  cleaned = cleaned.replace(/,/g, '').replace(/\s/g, '');
  
  // Handle bracketed negatives: (123) => -123
  if (/^\(.*\)$/.test(cleaned)) {
    cleaned = '-' + cleaned.replace(/[()]/g, '');
  }
  
  const num = parseFloat(cleaned);
  return isNaN(num) ? 0 : num;
}

function detectCurrency(text: string): string | null {
  for (const symbol of CURRENCY_SYMBOLS) {
    if (text.includes(symbol)) {
      if (symbol === '₹' || symbol.startsWith('Rs')) return 'INR';
      if (symbol === '$' || symbol === 'USD') return 'USD';
      if (symbol === '€' || symbol === 'EUR') return 'EUR';
      if (symbol === '£' || symbol === 'GBP') return 'GBP';
    }
  }
  return null;
}

function createStandardRow(partial: Partial<StandardBOQRow>): StandardBOQRow {
  return {
    srNo: partial.srNo || '',
    category: partial.category || '',
    subCategory: partial.subCategory || '',
    description: partial.description || '',
    unit: partial.unit || '',
    quantity: partial.quantity || 0,
    tenderRate: partial.tenderRate || 0,
    tenderAmount: partial.tenderAmount || 0,
    itemCode: partial.itemCode || null,
    currency: partial.currency || null,
    lumpSum: partial.lumpSum || false,
    altGroup: partial.altGroup || null,
    remark: partial.remark || false,
    subtotal: partial.subtotal || false,
    grandTotal: partial.grandTotal || false,
    sheetName: partial.sheetName || null,
    rawRowIndex: partial.rawRowIndex || 0,
    original: partial.original || {}
  };
}

// ==================== EXPORTS ====================

export const boqParser = {
  parseBoqFile,
  mapHeaders: mapHeaderRow,
  mergeMultiLineRows: (rows: any[][]) => rows // Placeholder for Phase 3
};

export default boqParser;
